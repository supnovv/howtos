Bleutooth
=========

https://www.bluetooth.com/specifications
https://source.android.com/devices/bluetooth/


安卓ADB命令
----------

adb shell
pm disable com.android.voicememo
killall com.android.phonemotion
dumpsys activity services | grep -i "ConnectionRecord.*headsetservice"| wc -l

adb logcat -c       # clear log
adb logcat -b all   # enable all log buffers

更新固件驱动
----------

cd ADSP.VT.4.0/adsp_proc/
edit your modification
cd ../..
./project_build.sh -a eng <TARGET_PRODUCT>
adb root
adb remount
adb shell mount -o rw,remount /firmware
adb shell rm /firmware/image/adsp*
adb push ADSP.VT.4.0/adsp_proc/obj/qdsp6v5_ReleaseG/660.adsp.prod/LA/system/etc/firmware/* /firmware/image/
adb shell sync
adb reboot

cd RPM.BF.1.8/rpm_proc/
edit your modification
cd ../..
./project_build.sh -r eng <TARGET_PRODUCT>
cd RPM.BF.1.8/rpm_proc/
find -name rpm.mbn
adb reboot bootloader
fastboot flash rpm build/ms/bin/AAAAANAZR/signed/rpm.mbn
fastboot reboot


安卓调试关键字
------------

电量/灭屏/睡眠（toggled 0 为灭屏）
screen_toggled|ThrmLimit:CHARGE|Thrm Limit|battery|Suspend entry \\-|msm_mpm_exit_sleep
谷歌GMS相关
ro.com.google.gmsversion


Bluetooth QCOM FTM (Factory Test Mode)
--------------------------------------

1. Make sure BT is turned off
2. adb remount
3. adb shell setprop sys.usb.config diag,serial_tty,serial_tty,adb
4. adb shell ftmdaemon -n
5. Start QRCT3 as an administrator
6. Refresh and Set COM Port
7. Menu > FTM Command > BT > Choose "HCI Commands" and Start BT HCI Commands
8. Press HCI Reset button and confirm it succeeds
9. Press DUT Mode button and confirm it suceeds
0. Press Enable button which is in group of HCI Write Scan Enable and confirm it suceeds
1. Press Set Filter button which is in group of HCI Set Event Filter and confirm it suceeds


Bluetooth FTM source files
--------------------------

vendor/qcom/proprietary/ftm
=> ftm_main.c
   ftm_bt.c
   ftm_bt_hci_pfal_linux.c


Enable FTM debug logs
---------------------

> ftm_dbg.h
#define DEBUG
#define FTM_DBG_DEFAULT (0xff)

> ftm_main.c, ftm_bt.c, ftm_bt_hci_pfal_linux.c
#define FTM_DEBUG
#define printf(...) fprintf(stderr, __VA_ARGS__)


Bluetooth FTM code flow
-----------------------

1. enter main() and register bt_ftm_diag_func_table
2. wait hci command queued by QRCT3 tool
3. QRCT3 tool call bt_ftm_diag_func_table.bt_ftm_diag_dispatch() insert hci command
4. main() waited semaphore_cmd_queued, and start send command
5. for the 1st time, init BT and create ftm reader thread
6. write hci command to BT controller
7. wait previous hci command complete
8. ftm reader thread handle hci event response from BT controller
9. main() waited semaphore_cmd_complete, and try to wait next hci command

```
ftm_main.c$main()
DIAGPKT_DISPATCH_TABLE_REGISTER(DIAG_SUBSYS_FTM, bt_ftm_diag_func_table) ★ (1)
wait previous semaphore_cmd_complete ★ (7)
wait semaphore_cmd_queued ★ (2) (9)
dequeue_send() ★ (4)
ftm_bt_dispatch()
ftm_bt_hci_send_cmd()
ftm_bt_hal_soc_init(MODE_BT) => ftm_bt_hci_pfal_init_transport() => pthread_create( &hci_cmd_thread_hdl, NULL, ftm_readerthread, NULL) ★ (5)
ftm_bt_hci_pfal_nwrite(cmd, size) ★ (6)

bt_ftm_diag_func_table.bt_ftm_diag_dispatch() ★ (3)
qinsert_cmd(req_pkt)
post semaphore_cmd_queued "Insert BT packet done"

ftm_readerthread() ★ (8)
ftm_bt_hci_qcomm_handle_event()
ftm_bt_hci_hal_read_event()
post semaphore_cmd_complete
```

OPP (Object Push Profile)
-------------------------

> BluetoothOppService

BluetoothOppService 是一个 ProfileService，跟随蓝牙开关而 create 和 destroy。
而如果有多个蓝牙用户比如（测试BYOD NFC Beam就是如此）
```
calligUid != Process.BLUETOOTH_UID && UserHandle.getAppId(calligUid) == Process.BLUETOOTH_UID 
```
需要在必要时手动启动 BluetoothOppService，像这样:
```
context.startService(new Intent(context, BluetoothOppService.class))
```
另外手动启动的 BluetoothOppService 需要手动关闭，可以在 mBluetoothReceiver.onReceive() 中
追踪到蓝牙关闭时，调用 stopSelf() 关闭 BluetoothOppService，如果不关闭当蓝牙字啊次开启时，它会
工作不正常，收不到 Intent 以及 BluetoothOppProvider 发送的 notifyChange。

> BluetoothOppHandoverReceiver

NFC Beam 通过蓝牙传输文件的流程：
* BluetoothOppHandoverReceiver 收到 ACTION_HANDOVER_SEND 或 ACTION_HANDOVER_SEND_MULTIPLE
* 此时如果 BluetoothOppService 在当前进程中没有启动，可以在这里先启动起来
* 调用 BluetoothOppManager.saveSendingFileInfo() 保存文件信息
* 调用 BluetoothOppManager.startTransfer() 启动传输
* startTransfer() 会启动 InsertShareInfoThread 线程，执行 insertSingleShare 或 insertMultipleShare
* 这个两个 insert 函数将文件信息插入到 BluetoothOppProvider 名为 BluetoothShare.CONTENT_URI 表中
  mContext.getContentResolver().insert(BluetoothShare.CONTENT_URI, contentValues);
* BluetoothOppProvider 的 insert 函数插入数据后，会调用 notifyChange() 通知 BluetoothOppService
  context.getContentResolver().notifyChange(uri, null);
* 实际上 BluetoothOppService 在创建时会注册 ContentObserver 监听 BluetoothShare.CONTENT_URI
  getContentResolver().registerContentObserver(BluetoothShare.CONTENT_URI, true, mObserver);
* BluetoothOppService 收到 notifyChange 通知后，会调用 updateFromProvider（） 来处理 UPDATE_PROVIDER
* updateFromProvider（） 启动 UpdateThread 线程，最后调用到 insertShare() 触发 BluetoothOppTransfer 真正启动传输 


PBAP (Phonebook Access Profile)
-------------------------------

> Phone Own Number
adb shell setprop log.tag.BluetoothPbap VERBOSE
Connect to remote device and enable PBAP permission
```
telecom/pb.vcf       - main phonebook object
SIM1/telecom/pb.vcf 
telecom/och.vcf      - outgoing calls history object
SIM1/telecom/och.vcf 
telecom/ich.vcf      - incoming calls history object
SIM1/telecom/ich.vcf 
telecom/mch.vcf      - missed calls history object
SIM1/telecom/mch.vcf 
cch.vcf              - combined calls history object
spd.vcf              - speed-dial object
fav.vcf              - favorite contacts object
---
BluetoothPbapObexServer.java: OnGet type is x-bt/phonebook; name is telecom/pb.vcf
BluetoothPbapVcardManager.java: phone own number vcard
BluetoothPbapService.java: getLine1Number()
---

