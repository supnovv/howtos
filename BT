Bleutooth
=========

https://www.bluetooth.com/specifications
https://source.android.com/devices/bluetooth/

system/bt
packages/apps/Bluetooth
frameworks/base/core/java/android/bluetooth
frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth
frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles
frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy
frameworks/base/services/core/java/com/android/server
packages/apps/Settings/src/com/android/settings/bluetooth
vendor/qcom/opensource/bluetooth
vendor/qcom/opensource/bluetooth_ext
vendor/qcom/proprietary/bt
vendor/qcom/proprietary/bluetooth
device/qcom/common/


安卓ADB命令
----------

adb shell
pm disable com.android.voicememo
killall com.android.phonemotion
dumpsys activity services | grep -i "ConnectionRecord.*headsetservice"| wc -l

adb logcat -c       # clear log
adb logcat -b all   # enable all log buffers


更新固件驱动
----------

cd ADSP.VT.4.0/adsp_proc/
edit your modification
cd ../..
./project_build.sh -a eng <TARGET_PRODUCT>
adb root
adb remount
adb shell mount -o rw,remount /firmware
adb shell rm /firmware/image/adsp*
adb push ADSP.VT.4.0/adsp_proc/obj/qdsp6v5_ReleaseG/660.adsp.prod/LA/system/etc/firmware/* /firmware/image/
adb shell sync
adb reboot

cd RPM.BF.1.8/rpm_proc/
edit your modification
cd ../..
./project_build.sh -r eng <TARGET_PRODUCT>
cd RPM.BF.1.8/rpm_proc/
find -name rpm.mbn
adb reboot bootloader
fastboot flash rpm build/ms/bin/AAAAANAZR/signed/rpm.mbn
fastboot reboot


Settings (packages/apps/Settings)
---------------------------------

> layout xml

res/layout/preference_progress_category.xml
src/com/android/settings/bluetooth/BluetoothProgressCategory.java

> Connected devices 设置相关

CATEGORY_DEVICE
connected_devices
connected_devices_dashboard_title
connected_devices_dashboard_summary
bluetooth_settings_title
com.android.settings.category.ia.device
BluetoothSettingsActivity
BluetoothSettings
ConnectedDeviceDashboardActivity
ConnectedDeviceDashboardFragment
BluetoothMasterSwitchPreferenceController
AndroidManifest.xml
res/xml/connected_devices.xml

> 配对新设备流程（Pair new device）

BluetoothPairingPreferenceController.createBluetoothPairingPreference() // 初始化 Pair new device 元素界面
BluetoothPairingPreferenceController.handlePreferenceTreeClick()　// 点击 Pair new device 元素
startPreferencePanelAsUser(bluetooth_pairing_page_title => "Pair new device" BluetoothPairingDetail.class)
BluetoothPairingDetail extends from DeviceListPreferenceFragment.java
DeviceListPreferenceFragment.enableScanning()
AdapterService.startScanning()
startDiscoveryNative()
device_found_callback()
RemoteDevices.deviceFoundCallback() => BluetoothDevice.ACTION_FOUND
BluetoothEventManager.DeviceFoundHandler.onReceive()
BluetoothCallback.onDeviceAdded(cachedDevice)
DeviceListPreferenceFragment.onDeviceAdded()
DeviceListPreferenceFragment.createDevicePreference()
PreferenceGroup.addPreference(new BluetoothDevicePreference())

> 蓝牙设定里的连接状态更新

LocalBluetoothProfileManager.addProfile(profile, name, ACTION_CONNECTION_STATE_CHANGED)
BluetoothEventManager.mBroadcastReceiver() => handler.onReceive()
LocalBluetoothProfileManager.StateChangedHandler().onReceive()
=> cachedDevice.onProfileStateChanged(mProfile, newState)
   mProfileConnectionState.put(profile)
=> cachedDevice.refresh()
   BluetoothDevicePreference.onDeviceAttributesChanged()
   cachedDevice.getConnectionSummary()
   cachedDevice.getProfileConnectionState()

> 状态栏里的蓝牙连接状态更新

BluetoothEventManager.dispatchDeviceAdded() -> BluetoothCallback.onDeviceAdded()
BluetoothEventManager.DeviceDisappearedHandler.onReceive() -> BluetoothCallback.onDeviceDeleted()
BluetoothEventManager.BondStateChangedHandler.onReceive() -> BluetoothCallback.onDeviceBondStateChanged()
BluetoothEventManager.dispatchConnectionStateChanged() -> BluetoothCallback.onConnectionStateChanged()
CachedBluetoothDevice.dispatchAttributesChanged() -> CachedBluetoothDevice.Callback.onDeviceAttributesChanged()

BluetoothControllerImpl.onDeviceAdded()
| BluetoothControllerImpl.onDeviceDeleted()
| BluetoothControllerImpl.onDeviceBondStateChanged()
| BluetoothControllerImpl.onDeviceAttributesChanged()
BluetoothControllerImpl.H.handleMessage() MSG_PAIRED_DEVICES_CHANGED
BluetoothControllerImpl.H.firePairedDevicesChanged() -> onBluetoothDevicesChanged()
PhoneStatusBarPolicy.updateBluetooth() *** [1]

BluetoothControllerImpl.onDeviceAdded()
| BluetoothControllerImpl.onDeviceDeleted()
| BluetoothControllerImpl.onDeviceBondStateChanged()
| BluetoothControllerImpl.onDeviceAttributesChanged()
| BluetoothControllerImpl.onConnectionStateChanged()
BluetoothControllerImpl.updateConnected() when connected state changed
BluetoothControllerImpl.H.handleMessage() MSG_STATE_CHANGED
BluetoothControllerImpl.H.fireStateChange() -> onBluetoothStateChange()
PhoneStatusBarPolicy.onBluetoothStateChange()
PhoneStatusBarPolicy.updateBluetooth() *** [2]

BluetoothControllerImpl.onBluetoothStateChanged()
| BluetoothControllerImpl.onConnectionStateChanged()
BluetoothControllerImpl.H.handleMessage() MSG_STATE_CHANGED
BluetoothControllerImpl.H.fireStateChange() -> onBluetoothStateChange()
PhoneStatusBarPolicy.onBluetoothStateChange()
PhoneStatusBarPolicy.updateBluetooth() *** [3]
=> BluetoothControllerImpl.isBluetoothConnected()
   LocalBluetoothManager.getBluetoothAdapter().getConnectionState()
   BluetoothAdapter.getConnectionState()
   AdapterService.getAdapterConnectionState()
   AdapterProperties.getConnectionState()

> BLE apk 连接后的状态栏状态更新

. 在 GattService.onConnected()/onDisconnected()/onClientConnUpdate()/onClientConnected() 中跟踪 GATT 连接状态变化
. 如广播 com.example.bluetooth.gatt.profile.action.CONNECTION_STATE_CHANGED 消息给上层
. 然后在 BluetoothEventManager() 中注册监听这个广播 addHandler(...CONNECTION_STATE_CHANGED, new ConnectionStateChangedHandler())
. 然后当 GATT 连接状态变化时，会触发 BluetoothControllerImpl.onBluetoothStateChanged() -> PhoneStatusBarPolicy.updateBluetooth()
. PhoneStatusBarPolicy.updateBluetooth() 调用 BluetoothControllerImpl.isBluetoothConnected() 确认蓝牙是否处于连接状态
. 可以在 isBluetoothConnected（） 中添加检查是否有 GATT 连接的代码，是的 BLE 在 apk 上的连接状态会同步到状态栏上
. 获取 GATT 连接的代码: getSystemService(Context.BLUETOOTH_SERVICE).getConnectedDevices(BluetoothProfile.GATT)


安卓调试关键字
------------

电量/灭屏/睡眠（toggled 0 为灭屏）
screen_toggled|ThrmLimit:CHARGE|Thrm Limit|battery|Suspend entry \\-|msm_mpm_exit_sleep
谷歌GMS相关
ro.com.google.gmsversion


Bluetooth QCOM FTM (Factory Test Mode)
--------------------------------------

1. Make sure BT is turned off
2. adb remount
3. adb shell setprop sys.usb.config diag,serial_tty,serial_tty,adb
4. adb shell ftmdaemon -n
5. Start QRCT3 as an administrator
6. Refresh and Set COM Port
7. Menu > FTM Command > BT > Choose "HCI Commands" and Start BT HCI Commands
8. Press HCI Reset button and confirm it succeeds
9. Press DUT Mode button and confirm it suceeds
0. Press Enable button which is in group of HCI Write Scan Enable and confirm it suceeds
1. Press Set Filter button which is in group of HCI Set Event Filter and confirm it suceeds


Bluetooth FTM source files
--------------------------

vendor/qcom/proprietary/ftm
=> ftm_main.c
   ftm_bt.c
   ftm_bt_hci_pfal_linux.c


Enable FTM debug logs
---------------------

> ftm_dbg.h
#define DEBUG
#define FTM_DBG_DEFAULT (0xff)

> ftm_main.c, ftm_bt.c, ftm_bt_hci_pfal_linux.c
#define FTM_DEBUG
#define printf(...) fprintf(stderr, __VA_ARGS__)


Bluetooth FTM code flow
-----------------------

1. enter main() and register bt_ftm_diag_func_table
2. wait hci command queued by QRCT3 tool
3. QRCT3 tool call bt_ftm_diag_func_table.bt_ftm_diag_dispatch() insert hci command
4. main() waited semaphore_cmd_queued, and start send command
5. for the 1st time, init BT and create ftm reader thread
6. write hci command to BT controller
7. wait previous hci command complete
8. ftm reader thread handle hci event response from BT controller
9. main() waited semaphore_cmd_complete, and try to wait next hci command

```
ftm_main.c$main()
DIAGPKT_DISPATCH_TABLE_REGISTER(DIAG_SUBSYS_FTM, bt_ftm_diag_func_table) ★ (1)
wait previous semaphore_cmd_complete ★ (7)
wait semaphore_cmd_queued ★ (2) (9)
dequeue_send() ★ (4)
ftm_bt_dispatch()
ftm_bt_hci_send_cmd()
ftm_bt_hal_soc_init(MODE_BT) => ftm_bt_hci_pfal_init_transport() => pthread_create( &hci_cmd_thread_hdl, NULL, ftm_readerthread, NULL) ★ (5)
ftm_bt_hci_pfal_nwrite(cmd, size) ★ (6)

bt_ftm_diag_func_table.bt_ftm_diag_dispatch() ★ (3)
qinsert_cmd(req_pkt)
post semaphore_cmd_queued "Insert BT packet done"

ftm_readerthread() ★ (8)
ftm_bt_hci_qcomm_handle_event()
ftm_bt_hci_hal_read_event()
post semaphore_cmd_complete
```

OPP (Object Push Profile)
-------------------------

> BluetoothOppService

BluetoothOppService 是一个 ProfileService，跟随蓝牙开关而 create 和 destroy。
而如果有多个蓝牙用户比如（测试BYOD NFC Beam就是如此）
```
calligUid != Process.BLUETOOTH_UID && UserHandle.getAppId(calligUid) == Process.BLUETOOTH_UID 
```
需要在必要时手动启动 BluetoothOppService，像这样:
```
context.startService(new Intent(context, BluetoothOppService.class))
```
另外手动启动的 BluetoothOppService 需要手动关闭，可以在 mBluetoothReceiver.onReceive()
中追踪到蓝牙关闭时，调用 stopSelf() 关闭 BluetoothOppService，如果不关闭当蓝牙再次开启时，会
工作不正常，收不到 Intent 以及 BluetoothOppProvider 发送的 notifyChange。

> BluetoothOppHandoverReceiver

NFC Beam 通过蓝牙传输文件的流程：
* BluetoothOppHandoverReceiver 收到 ACTION_HANDOVER_SEND 或 ACTION_HANDOVER_SEND_MULTIPLE
* 此时如果 BluetoothOppService 在当前进程中没有启动，可以在这里先启动起来
* 调用 BluetoothOppManager.saveSendingFileInfo() 保存文件信息
* 调用 BluetoothOppManager.startTransfer() 启动传输
* startTransfer() 会启动 InsertShareInfoThread 线程，执行 insertSingleShare 或 insertMultipleShare
* 这个两个 insert 函数将文件信息插入到 BluetoothOppProvider 名为 BluetoothShare.CONTENT_URI 表中
  mContext.getContentResolver().insert(BluetoothShare.CONTENT_URI, contentValues);
* BluetoothOppProvider 的 insert 函数插入数据后，会调用 notifyChange() 通知 BluetoothOppService
  context.getContentResolver().notifyChange(uri, null);
* 实际上 BluetoothOppService 在创建时会注册 ContentObserver 监听 BluetoothShare.CONTENT_URI
  getContentResolver().registerContentObserver(BluetoothShare.CONTENT_URI, true, mObserver);
* BluetoothOppService 收到 notifyChange 通知后，会调用 updateFromProvider（） 来处理 UPDATE_PROVIDER
* updateFromProvider（） 启动 UpdateThread 线程，最后调用到 insertShare() 触发 BluetoothOppTransfer 真正启动传输 


PBAP (Phonebook Access Profile)
-------------------------------

> Phone Own Number
adb shell setprop log.tag.BluetoothPbap VERBOSE
Connect to remote device and enable PBAP permission
```
telecom/pb.vcf       - main phonebook object
SIM1/telecom/pb.vcf 
telecom/och.vcf      - outgoing calls history object
SIM1/telecom/och.vcf 
telecom/ich.vcf      - incoming calls history object
SIM1/telecom/ich.vcf 
telecom/mch.vcf      - missed calls history object
SIM1/telecom/mch.vcf 
cch.vcf              - combined calls history object
spd.vcf              - speed-dial object
fav.vcf              - favorite contacts object
---
BluetoothPbapObexServer.java: OnGet type is x-bt/phonebook; name is telecom/pb.vcf
BluetoothPbapVcardManager.java: phone own number vcard
BluetoothPbapService.java: getLine1Number()
---

