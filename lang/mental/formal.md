
文法G是一个四元组`G = (V, T, P, S)`，其中V是非终结符（也称为语法变量）集合，T是终结符集合，P是所有产生式形成的集合，而S是起始符号（属于集合V），则：

1. 如果对于文法的任意属于P的产生式，均具有如下形式（其中A和B属于V是语法变量，w属于T是对应字符集上的终结符号）
```c
A -> w
A -> wB
```
那么称G为正则文法（Regular Grammar, RG），对应地根据该文法形成的语言L(G)称为正则语言（RL）。

2. 如果所有产生式都满足（其中A是语法变量，β是非终结符和终结符形成的序列）
```c
A -> β
```
且β的长度（其中非终结符和终结符的个数）|β|大于等于1，那么称G为上下文无关文法（Context Free Grammar, CFG），对应地根据该文法形成的语言L(G)称为上下文无关语言（CFL）。上下文无关文法的含义是，无论语法变量A出现在句型的任何位置，都可以将A替换成β而不用考虑A所处的上下文。它跟下面定义的上下文有关文法的区别是，它的产生式的左边只能是单独的一个语法变量符号，进行替换时可以独立的进行替换。而上下文有关文法不能，它牵扯到周围的语法变量或终结符号，要进行替换，α中的语法变量和终结符号需要一起替换。

3. 如果所有产生式都满足（其中α和β都是由非终结符和终结符形成的序列）
```c
α -> β
```
其β的长度总大于等于α的长度`|β|>=|α|`，那么称G为上下文有关语言（Context Sensitive Grammar, CSG），对应地根据该文法形成的语言L(G)称为上下文有关语言（CSL）。

4. 如果对文法的产生式不做任何限制，那么称对应的文法G为短语结构文法（Phrase Structure Grammar, PSG），根据该文法形成的语言L(G)称为短语结构语言（PSL）、或递归可枚举集（Recursively Enumerable Set）。

## Regex (Regular Expression)
```c
 1. .   点号匹配除换行符(\n)之外的任意单一字符
 2. ^   匹配行首
 3. $   匹配行尾
 4. *   匹配0个或多个
 5. +   匹配1个或多个
 6. ?   匹配0个或1个
 7. |   只要匹配其中之一即匹配成功，例如"a"|"bc"
 8. ()  将匹配表达式组合成一个新的表达式
 9. {n} {n,m} {n,} 匹配n个、n个到m个，大于等于n个，例如("a"|"bc"){8}
10. /   匹配斜杠之前的表达式，但是要求之后的字符串也要匹配斜杠之后的表达式，如"0"/"1"匹配"01"中的0，但不匹配"02"中的0
11. "abc" 匹配对应的字符串
12. ```abc\t\u0A1F``` 匹配对应的原始(没有进行转义的)字符串
13. {Expr} 匹配对应名称的表达式 
14. 字符集合：['0-9' 'a' '\t' '\u0A1F' '\'' ']' '[' '.'] [^ '0' 'A-Z' '^']
15. 字符差集：[]{-}[]，可扩展到表达式匹配差集？{Expr1 - Expr2}
16. 字符并集：[]{+}[]，可扩展到表达式匹配并集？{Expr1 + Expr2}

*每个模式只允许一个尾部上下文操作符，而且一个模式不能既有斜线又有尾部的$
*二义性处理：使用贪婪法尽可能多的匹配输入串；先定义的优先匹配，例如"+"和"+="；
```

## Peg (Parsing Expression Grammars)
```c
n: 匹配n个字符
"abc": 匹配字符a和b和c
Before(Expr): 当前位置之前匹配表达式Expr，不消耗字符
Range("az"), Range("az", "09", "AA", "BC"): 字符范围
Set("abc*/+"): 匹配其中的单一字符
#Expr: 当前位置之后匹配Expr，不消耗字符
-Expr: 只要当不匹配Expr是才匹配成功
Expr1+Expr2: 匹配其中一个表达式即匹配成功
Expr1-Expr2: 只要当不匹配Expr2但匹配Expr1时才匹配成功
Expr1*Expr2: 匹配Expr1并且匹配Expr2是才匹配成功
Expr^n: 匹配n个或多个Expr1
```
