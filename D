
static void*
lua_alloc_func(void* ud, void* p, size_t oldsz, size_t newsz)
{
  if (newsz == 0) {
    printf("free %d\n", (int)oldsz);
    l_rawapi_mfree(ud, p);
    return 0;
  } else if (p == 0) {
    printf("alloc %d\n", (int)newsz);
    return l_rawapi_malloc(ud, newsz);
  } else {
    printf("free %d and alloc %d\n", (int)oldsz, (int)newsz);
    return realloc(p, newsz);
  }
}

#define l_mallocEx(allocfunc, ud, size) allocfunc((ud), 0, 0, (size))
#define l_callocEx(allocfunc, ud, size) allocfunc((ud), 0, 1, (size))
#define l_rallocEx(allocfunc, ud, buffer, oldsize, newsize) allocfunc((ud), (buffer), (oldsize), (newsize))
#define l_mfreeEx(allocfunc, ud, buffer) allocfunc((ud), (buffer), 0, 0)

#define l_malloc(allocfunc, size) l_mallocEx(allocfunc, 0, (size))
#define l_calloc(allocfunc, size) l_callocEx(allocfunc, 0, (size))
#define l_ralloc(allocfunc, buffer, oldsize, newsize) l_rallocEx(allocfunc, 0, (buffer), (oldsize), (newsize))
#define l_mfree(allocfunc, buffer) l_mfreeEx(allocfunc, 0, (buffer))

#define l_raw_malloc(size) l_malloc(l_raw_alloc_func, size)
#define l_raw_calloc(size) l_calloc(l_raw_alloc_func, size)
#define l_raw_ralloc(buffer, oldsize, newsize) l_ralloc(l_raw_alloc_func, buffer, oldsize, newsize)
#define l_raw_mfree(buffer) l_mfree(l_raw_alloc_func, buffer)

typedef void* (*l_allocfunc)(void* userdata, void* buffer, l_int oldsize, l_int newsize);
L_EXTERN void* l_raw_alloc_func(void* userdata, void* buffer, l_int oldsize, l_int newsize);

static void*
l_out_of_memory(l_int size, int init)
{
  l_process_exit();
  (void)size;
  (void)init;
  return 0;
}

static l_int
l_check_alloc_size(l_int size)
{
  if (size > L_MAX_RWSIZE) return 0;
  if (size <= 0) return 8;
  return (((size - 1) >> 3) + 1) << 3; /* times of eight */
}

static void*
l_raw_alloc_f(void* p) {
  if (p) free(p);
  return 0;
}

static void*
l_raw_alloc_m(l_int size)
{
  void* p = 0;
  l_int n = l_check_alloc_size(size);
  if (!n) {
    l_loge_1("large %d", ld(size));
  } else {
    if (!(p = malloc(l_cast(size_t, n)))) {
      p = l_out_of_memory(n, 0);
    }
  }
  return p; /* the memory is not initialized */
}

static void*
l_raw_alloc_c(l_int size) {
  void* p = 0;
  l_int n = l_check_alloc_size(size);
  if (!n) { l_loge_1("large %d", ld(size)); return 0; }
  /* void* calloc(size_t num, size_t size); */
  p = calloc(l_cast(size_t, n) >> 3, 8);
  if (p) return p;
  return l_out_of_memory(n, 1);
}

static void* /* if alloc failed, need keep p unchanged */
l_raw_alloc_r(void* p, l_int old, l_int newsz) {
  void* temp = 0;
  l_int n = l_check_alloc_size(newsz);
  if (!p || old <= 0 || n == 0) { l_loge_1("size %d", ld(newsz)); return 0; }

  /** void* realloc(void* buffer, size_t size); **
  Changes the size of the memory block pointed by buffer. The function
  may move the memory block to a new location (its address is returned
  by the function). The content of the memory block is preserved up to
  the lesser of the new and old sizes, even if the block is moved to a
  new location. ***If the new size is larger, the value of the newly
  allocated portion is indeterminate***.
  In case of that buffer is a null pointer, the function behaves like malloc,
  assigning a new block of size bytes and returning a pointer to its beginning.
  If size is zero, the memory previously allocated at buffer is deallocated
  as if a call to free was made, and a null pointer is returned. For c99/c11,
  the return value depends on the particular library implementation, it may
  either be a null pointer or some other location that shall not be dereference.
  If the function fails to allocate the requested block of memory, a null
  pointer is returned, and the memory block pointed to by buffer is not
  deallocated (it is still valid, and with its contents unchanged). */

  if (n > old) {
    temp = realloc(p, l_cast(size_t, n));
    if (temp) { /* the newly allocated portion is indeterminate */
      l_zero_n(temp + old, n - old);
      return temp;
    }
    if ((temp = l_out_of_memory(n, 0))) {
      l_copy_n(p, old, temp);
      l_zero_n(temp + old, n - old);
      l_raw_alloc_f(p);
      return temp;
    }
  } else {
    temp = realloc(p, l_cast(size_t, n));
    if (temp) return temp;
    if ((temp = l_out_of_memory(n, 0))) {
      l_copy_n(p, n, temp);
      l_raw_alloc_f(p);
      return temp;
    }
  }
  return 0;
}

L_EXTERN void*
l_raw_alloc_func(void* userdata, void* buffer, l_int oldsize, l_int newsize)
{
  (void)userdata;
  if (!buffer) {
    if (oldsize) return l_raw_alloc_c(newsize);
    return l_raw_alloc_m(newsize);
  }
  if (newsize) return l_raw_alloc_r(buffer, oldsize, newsize);
  return l_raw_alloc_f(buffer);
}
