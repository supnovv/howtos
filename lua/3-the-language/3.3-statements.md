
## 3.3 Statements

Lua supports an almost conventional set of statements, similar to those in Pascal or C. 
This set includes assignments, control structures, function calls, and variable declarations.

Lua支持大部分常用语句，跟Pascal和C相似。包括赋值、结构控制、函数调用、以及变量声明。

### 3.3.1 Blocks

A block is a list of statements, which are executed sequentially:
```
block ::= {stat}
```
Lua has empty statements that allow you to separate statements with semicolons, 
start a block with a semicolon or write two semicolons in sequence:
```
stat ::= ‘;’
```

语句块由多条语句组成，这些语句按顺序执行。
Lua中有空语句`;`，允许用来分隔语句、用在语句块开头、或连续写两个分号。

Function calls and assignments can start with an open parenthesis. 
This possibility leads to an ambiguity in Lua's grammar. 
Consider the following fragment:
```
a = b + c
(print or io.write)('done')
```
The grammar could see it in two ways:
```
a = b + c(print or io.write)('done')
a = b + c; (print or io.write)('done')
```
The current parser always sees such constructions in the first way, 
interpreting the open parenthesis as the start of the arguments to a call. 
To avoid this ambiguity, it is a good practice to always precede with a semicolon statements 
that start with a parenthesis:
```
;(print or io.write)('done')
```

函数调用和赋值语句可以用开始括号`(`开头，如果这个开始括号`(`单独成行，则有可能引起歧义，如上。
为避免这种混淆，好的做法是总在开始括号`(`前加上分号。

A block can be explicitly delimited to produce a single statement:
```
stat ::= do block end
```
Explicit blocks are useful to control the scope of variable declarations. 
Explicit blocks are also sometimes used to add a `return` statement in the middle of another block (see §3.3.4). 

可以用`do`和`end`定义显示语句块，使用显示语句块可以方便的控制变量的作用域。
显示语句块也用于在其他语句块中间插入`return`语句。

### 3.3.2 Chunks

The unit of compilation of Lua is called a chunk. 
Syntactically, a chunk is simply a block:
```
chunk ::= block
```
Lua handles a chunk as the body of an anonymous function with a variable number of arguments (see §3.4.11). 
As such, chunks can define local variables, receive arguments, and return values. 
Moreover, such anonymous function is compiled as in the scope of an external local variable called `_ENV` (see §2.2).
The resulting function always has `_ENV` as its only upvalue, even if it does not use that variable.

A chunk can be stored in a file or in a string inside the host program. 
To execute a chunk, Lua first loads it, precompiling the chunk's code into instructions for a virtual machine, 
and then Lua executes the compiled code with an interpreter for the virtual machine.

Chunks can also be precompiled into binary form; see program `luac` and function `string.dump` for details. 
Programs in source and compiled forms are interchangeable; 
Lua automatically detects the file type and acts accordingly (see `load`). 

Lua的编译单元称为chunk（Lua代码块），其语法上是一语句块。
Lua将chunk处理为带变长参数的匿名函数语句块，因而chunk内可以定义局部变量、接收参数、返回返回值。
而且，这个匿名函数编译在一个叫`_ENV`的局部变量作用域中，`_ENV`是其唯一的upvalue，不管它使不使用这个值。

宿主程序中，Lua代码块存储在文件或字符串中。
为执行代码块，首先需要加载将其预编译成虚拟机指令，然后用虚拟机指令解释器执行编译出的代码。

Lua代码块也可以预编译成二进制形式存储，细节可参考`luac`程序和`string.dump`函数。
这两种程序形式（文本源程序和编译后的二进制程序）可以相互转换。
Lua能自动根据文件内容以对应形式加载其中的代码块（见`load`）。

### 3.3.3 Assignment

Lua allows multiple assignments. Therefore, the syntax for assignment defines a list of variables on the left side 
and a list of expressions on the right side. The elements in both lists are separated by commas:
```
stat ::= varlist ‘=’ explist
varlist ::= var {‘,’ var}
explist ::= exp {‘,’ exp}
```
Expressions are discussed in §3.4.

Before the assignment, the list of values is adjusted to the length of the list of variables. 
If there are more values than needed, the excess values are thrown away. 
If there are fewer values than needed, the list is extended with as many `nil`'s as needed. 
If the list of expressions ends with a function call, 
then all values returned by that call enter the list of values, 
before the adjustment (except when the call is enclosed in parentheses; see §3.4).

Lua允许多重赋值，赋值左边为变量列表、右边为表达式列表，列表元素都用逗号分隔。
在赋值操作执行之前，右边值的个数会调整成与变量的个数相同，多余的值被丢弃，不足则使用`nil`填补。
如表达式列表以函数调用结束，则调整值的个数之前，函数所有返回值都会计入值列表中（除非函数调用包含在括号中，见3.4）。

The assignment statement first evaluates all its expressions and only then the assignments are performed. 
Thus the code
```
i = 3
i, a[i] = i+1, 20
```
sets `a[3]` to 20, without affecting `a[4]` because the `i` in `a[i]` is evaluated (to 3) before it is assigned 4. Similarly, the line
```
x, y = y, x
```
exchanges the values of `x` and `y`, and
```
x, y, z = y, z, x
```
cyclically permutes the values of `x`, `y`, and `z`.

赋值操作执行之前，会首先运算语句中所有表达式的值，如上述示例。

The meaning of assignments to global variables and table fields can be changed via metatables. 
An assignment to an indexed variable `t[i] = val` is equivalent to `settable_event(t,i,val)`. 
(See §2.4 for a complete description of the `settable_event` function. 
This function is not defined or callable in Lua. We use it here only for explanatory purposes.)

An assignment to a global name `x = val` is equivalent to the assignment `_ENV.x = val` (see §2.2). 

全局变量和表中变量的赋值含义能通过元表改变，`t[i]=val`相当于调用`settable_event(t,i,val)`
（`settable_event`函数的完整描述见2.4，这个函数不是实际的Lua函数，这里给出只是为了解释方便）。

### 3.3.4 Control Structures

The control structures `if`, `while`, and `repeat` have the usual meaning and familiar syntax:
```
stat ::= while exp do block end
stat ::= repeat block until exp
stat ::= if exp then block {elseif exp then block} [else block] end
```
Lua also has a `for` statement, in two flavors (see §3.3.5).

The condition expression of a control structure can return any value. 
Both `false` and `nil` are considered false. 
All values different from `nil` and `false` are considered true 
(in particular, the number 0 and the empty string are also true).

In the repeat–until loop, the inner block does not end at the until keyword, but only after the condition. 
So, the condition can refer to local variables declared inside the loop block.

The `goto` statement transfers the program control to a label. 
For syntactical reasons, labels in Lua are considered statements too:
```
stat ::= goto Name
stat ::= label
label ::= ‘::’ Name ‘::’
```
A label is visible in the entire block where it is defined, 
except inside nested blocks where a label with the same name is defined and inside nested functions. 
A `goto` may jump to any visible label as long as it does not enter into the scope of a local variable.

Labels and empty statements are called void statements, as they perform no actions.

The `break` statement terminates the execution of a `while`, `repeat`, or `for` loop, 
skipping to the next statement after the loop:
```
stat ::= break
```
A `break` ends the innermost enclosing loop.

The `return` statement is used to return values from a function or a chunk (which is an anonymous function). 
Functions can return more than one value, so the syntax for the return statement is
```
stat ::= return [explist] [‘;’]
```
The return statement can only be written as the last statement of a block. 
If it is really necessary to return in the middle of a block, then an explicit inner block can be used, 
as in the idiom `do return end`, because now `return` is the last statement in its (inner) block.

### 3.3.5 For Statement

The `for` statement has two forms: one numerical and one generic.

The numerical for loop repeats a block of code while a control variable runs through an arithmetic progression. 
It has the following syntax:
```
stat ::= for name ‘=’ exp ‘,’ exp [‘,’ exp] do block end
```
The block is repeated for `name` starting at the value of the first `exp`, 
until it passes the second `exp` by steps of the third `exp`. 
More precisely, a for statement like
```
for v = e1, e2, e3 do block end
```
is equivalent to the code:
```
     do
       local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)
       if not (var and limit and step) then error() end
       var = var - step
       while true do
         var = var + step
         if (step >= 0 and var > limit) or (step < 0 and var < limit) then
           break
         end
         local v = var
         block
       end
     end
```
Note the following:
- All three control expressions are evaluated only once, before the loop starts. They must all result in numbers.
- `var`, `limit`, and `step` are invisible variables. The names shown here are for explanatory purposes only.
- If the third expression (the `step`) is absent, then a step of 1 is used.
- You can use `break` and `goto` to exit a for loop.
- The loop variable `v` is local to the loop body. 
  If you need its value after the loop, assign it to another variable before exiting the loop.

The generic for statement works over functions, called iterators. 
On each iteration, the iterator function is called to produce a new value, stopping when this new value is `nil`. 
The generic `for` loop has the following syntax:
```
stat ::= for namelist in explist do block end
namelist ::= Name {‘,’ Name}
```
A for statement like
```
for var_1, ···, var_n in explist do block end
```
is equivalent to the code:
```
     do
       local f, s, var = explist
       while true do
         local var_1, ···, var_n = f(s, var)
         if var_1 == nil then break end
         var = var_1
         block
       end
     end
```
Note the following:
- `explist` is evaluated only once. 
  Its results are an iterator function, a state, and an initial value for the first iterator variable.
- `f`, `s`, and `var` are invisible variables. The names are here for explanatory purposes only.
- You can use break to exit a for loop.
- The loop variables `var_i` are local to the loop; you cannot use their values after the for ends. 
  If you need these values, then assign them to other variables before breaking or exiting the loop.

### 3.3.6 Function Calls as Statements

To allow possible side-effects, function calls can be executed as statements:
```
stat ::= functioncall
```
In this case, all returned values are thrown away. Function calls are explained in §3.4.10.

### 3.3.7 Local Declarations

Local variables can be declared anywhere inside a block. The declaration can include an initial assignment:
```
stat ::= local namelist [‘=’ explist]
```
If present, an initial assignment has the same semantics of a multiple assignment (see §3.3.3). 
Otherwise, all variables are initialized with `nil`.

A chunk is also a block (see §3.3.2), and so local variables can be declared in a chunk outside any explicit block.
The visibility rules for local variables are explained in §3.5.

[3.4 Expressions](./3.4-expressions.md)
