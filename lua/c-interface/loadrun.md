
## lua_Reader

```c
typedef const char* (*lua_Reader) (lua_State *L, void *data, size_t *size);
```
The reader function used by `lua_load`. 
Every time it needs another piece of the chunk, `lua_load` calls the reader, passing along its `data` parameter.
The reader must return a pointer to a block of memory with a new piece of the chunk 
and set size to the block size.
The block must exist until the reader function is called again. 
To signal the end of the chunk, the reader must return NULL or set size to zero. 
The reader function may return pieces of any size greater than zero.

## lua_load [-0, +1, –]
```c
int lua_load(lua_State* L, lua_Reader reader, void* data, const char* chunkname, const char* mode);
```
Loads a Lua chunk without running it. 
If there are no errors, `lua_load` pushes the compiled chunk as a Lua function on top of the stack. 
Otherwise, it pushes an error message.

The return values of `lua_load` are:
- LUA_OK: no errors;
- LUA_ERRSYNTAX: syntax error during precompilation;
- LUA_ERRMEM: memory allocation error;
- LUA_ERRGCMM: error while running a `__gc` metamethod. 
  (This error has no relation with the chunk being loaded. It is generated by the garbage collector.)

The `lua_load` function uses a user-supplied reader function to read the chunk (see `lua_Reader`). 
The `data` argument is an opaque value passed to the reader function.

The chunkname argument gives a name to the chunk, 
which is used for error messages and in debug information (see §4.9).

`lua_load` automatically detects whether the chunk is text or binary 
and loads it accordingly (see program `luac`). 
The string mode works as in function `load`, 
with the addition that a `NULL` value is equivalent to the string "bt".

`lua_load` uses the stack internally, 
so the reader function must always leave the stack unmodified when returning.

If the resulting function has upvalues, its first upvalue is set to the value of the global environment 
stored at index `LUA_RIDX_GLOBALS` in the registry (see §4.5). 
When loading main chunks, this upvalue will be the `_ENV` variable (see §2.2). 
Other upvalues are initialized with `nil`.

## luaL_loadbuffer [-0, +1, –]

```c
int luaL_loadbuffer(lua_State *L, const char *buff, size_t sz, const char *name);
```                 
Equivalent to `luaL_loadbufferx` with `mode` equal to NULL.

## luaL_loadbufferx [-0, +1, –]

```c
int luaL_loadbufferx(lua_State *L, const char *buff, size_t sz, const char *name, const char *mode);
```
Loads a buffer as a Lua chunk. 
This function uses `lua_load` to load the chunk in the buffer pointed to by `buff` with size `sz`.

This function returns the same results as `lua_load`. 
`name` is the chunk name, used for debug information and error messages. 
The string mode works as in function `lua_load`.

## luaL_loadfile [-0, +1, e]

```c
int luaL_loadfile(lua_State *L, const char *filename);
```
Equivalent to `luaL_loadfilex` with mode equal to NULL.

## luaL_loadfilex [-0, +1, e]

```c
int luaL_loadfilex(lua_State *L, const char *filename, const char *mode);
```
Loads a file as a Lua chunk. This function uses lua_load to load the chunk in the file named filename. 
If filename is NULL, then it loads from the standard input. 
The first line in the file is ignored if it starts with a `#`.

The string mode works as in function `lua_load`.

This function returns the same results as `lua_load`, 
but it has an extra error code `LUA_ERRFILE` if it cannot open/read the file or the file has a wrong mode.

As `lua_load`, this function only loads the chunk; it does not run it.

## luaL_loadstring [-0, +1, –]

```c
int luaL_loadstring(lua_State *L, const char *s)
```
Loads a string as a Lua chunk. 
This function uses lua_load to load the chunk in the zero-terminated string `s`.

This function returns the same results as `lua_load`.

Also as `lua_load`, this function only loads the chunk; it does not run it.

lua_dump

[-0, +0, e]
int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);
Dumps a function as a binary chunk. Receives a Lua function on the top of the stack and produces a binary chunk that, if loaded again, results in a function equivalent to the one dumped. As it produces parts of the chunk, lua_dump calls function writer (see lua_Writer) with the given data to write them.

If strip is true, the binary representation may not include all debug information about the function, to save space.

The value returned is the error code returned by the last call to the writer; 0 means no errors.

This function does not pop the Lua function from the stack.

# Lua Stdlib

**load (chunk [, chunkname [, mode [, env]]])**

Loads a chunk. If chunk is a string, the `chunk` is this string. 
If `chunk` is a function, `load` calls it repeatedly to get the chunk pieces. 
Each call to chunk must return a string that concatenates with previous results. 
A return of an empty string, `nil`, or no value signals the end of the chunk.

If there are no syntactic errors, returns the compiled chunk as a function; 
otherwise, returns `nil` plus the error message.

If the resulting function has upvalues, the first upvalue is set to the value of `env`, 
if that parameter is given, or to the value of the global environment. 
Other upvalues are initialized with `nil`. 
(When you load a main chunk, the resulting function will always have exactly one upvalue, 
the `_ENV` variable (see §2.2).
However, when you load a binary chunk created from a function (see `string.dump`), 
the resulting function can have an arbitrary number of upvalues.) 
All upvalues are fresh, that is, they are not shared with any other function.

`chunkname` is used as the name of the chunk for error messages and debug information (see §4.9). 
When absent, it defaults to chunk if chunk is a string, or to `"=(load)"` otherwise.

The string `mode` controls whether the chunk can be text or binary (that is, a precompiled chunk). 
It may be the string `"b"` (only binary chunks), `"t"` (only text chunks), or `"bt"` (both binary and text). 
The default is `"bt"`.

Lua does not check the consistency of binary chunks. 
Maliciously crafted binary chunks can crash the interpreter.

**loadfile ([filename [, mode [, env]]])**

Similar to `load`, but gets the chunk from file filename or from the standard input, if no file name is given.

load (chunk [, chunkname [, mode [, env]]])

Loads a chunk.

If chunk is a string, the chunk is this string. If chunk is a function, load calls it repeatedly to get the chunk pieces. Each call to chunk must return a string that concatenates with previous results. A return of an empty string, nil, or no value signals the end of the chunk.

If there are no syntactic errors, returns the compiled chunk as a function; otherwise, returns nil plus the error message.

If the resulting function has upvalues, the first upvalue is set to the value of env, if that parameter is given, or to the value of the global environment. Other upvalues are initialized with nil. (When you load a main chunk, the resulting function will always have exactly one upvalue, the _ENV variable (see §2.2). However, when you load a binary chunk created from a function (see string.dump), the resulting function can have an arbitrary number of upvalues.) All upvalues are fresh, that is, they are not shared with any other function.

chunkname is used as the name of the chunk for error messages and debug information (see §4.9). When absent, it defaults to chunk, if chunk is a string, or to "=(load)" otherwise.

The string mode controls whether the chunk can be text or binary (that is, a precompiled chunk). It may be the string "b" (only binary chunks), "t" (only text chunks), or "bt" (both binary and text). The default is "bt".

Lua does not check the consistency of binary chunks. Maliciously crafted binary chunks can crash the interpreter.




loadfile ([filename [, mode [, env]]])

Similar to load, but gets the chunk from file filename or from the standard input, if no file name is given.

next (table [, index])

Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value. When called with nil as its second argument, next returns an initial index and its associated value. When called with the last index, or with nil in an empty table, next returns nil. If the second argument is absent, then it is interpreted as nil. In particular, you can use next(t) to check whether a table is empty.

The order in which the indices are enumerated is not specified, even for numeric indices. (To traverse a table in numerical order, use a numerical for.)

The behavior of next is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may clear existing fields.


dofile ([filename])
Opens the named file and executes its contents as a Lua chunk. When called without arguments, dofile executes the contents of the standard input (stdin). Returns all values returned by the chunk. In case of errors, dofile propagates the error to its caller (that is, dofile does not run in protected mode).

luaL_loadbuffer

[-0, +1, –]
int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);
Equivalent to luaL_loadbufferx with mode equal to NULL.

luaL_loadbufferx

[-0, +1, –]
int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);
Loads a buffer as a Lua chunk. This function uses lua_load to load the chunk in the buffer pointed to by buff with size sz.

This function returns the same results as lua_load. name is the chunk name, used for debug information and error messages. The string mode works as in function lua_load.

luaL_loadfile

[-0, +1, e]
int luaL_loadfile (lua_State *L, const char *filename);
Equivalent to luaL_loadfilex with mode equal to NULL.

luaL_loadfilex

[-0, +1, e]
int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);
Loads a file as a Lua chunk. This function uses lua_load to load the chunk in the file named filename. If filename is NULL, then it loads from the standard input. The first line in the file is ignored if it starts with a #.

The string mode works as in function lua_load.

This function returns the same results as lua_load, but it has an extra error code LUA_ERRFILE if it cannot open/read the file or the file has a wrong mode.

As lua_load, this function only loads the chunk; it does not run it.

luaL_loadstring

[-0, +1, –]
int luaL_loadstring (lua_State *L, const char *s);
Loads a string as a Lua chunk. This function uses lua_load to load the chunk in the zero-terminated string s.

This function returns the same results as lua_load.

Also as lua_load, this function only loads the chunk; it does not run it.

luaL_callmeta

[-0, +(0|1), e]
int luaL_callmeta (lua_State *L, int obj, const char *e);
Calls a metamethod.

If the object at index obj has a metatable and this metatable has a field e, this function calls this field passing the object as its only argument. In this case this function returns true and pushes onto the stack the value returned by the call. If there is no metatable or no metamethod, this function returns false (without pushing any value on the stack).

luaL_dofile

[-0, +?, e]
int luaL_dofile (lua_State *L, const char *filename);
Loads and runs the given file. It is defined as the following macro:

     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
It returns false if there are no errors or true in case of errors.

luaL_dostring

[-0, +?, –]
int luaL_dostring (lua_State *L, const char *str);
Loads and runs the given string. It is defined as the following macro:

     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
It returns false if there are no errors or true in case of errors.


## lua_call [-(nargs+1),+nresults,e]
```c
void lua_call(lua_State* L, int nargs, int nresults);
#define lua_call(L,n,r) lua_callk(L, (n), (r), 0, NULL)
```
> To call a function you must use the following protocol: first, the function to be called is pushed onto the stack;
then, the arguments to the function are pushed in direct order; that is, the first argument is pushed first.
Finally you call `lua_call`; `nargs` is the number of arguments that you pushed onto the stack.
All arguments and the function value are popped from the stack when the function is called.
The function results are pushed onto the stack when the function returns.
The number of results is adjust to `nresults`, unless `nresults` is LUA_MULTRET.
In this case, all results from the function are pushed.
Lua takes care that the returned values to fit into the stack sapce.
The function results are pushed onto the stack in direct order (the first result is pushed first),
so that after the call the last result is on the top of the stack.
Any error inside the called function is propagated upwards (with a `longjmp`). 

用C API调用Lua函数需要遵循如下规则：首先将要调用的函数入栈；
然后将函数的参数，从第一个到最后一个依次入栈。
最后调用`lua_call`执行函数，`nargs`表示传入的参数个数。
函数执行时，传入的参数和栈底的函数会出栈。函数返回时，会将函数的结果入栈。
结束的个数会调整到`nresults`个，除非`nresults`的值为LUA_MULTRET，此时函数所有的结果都会入栈。
Lua会管理好结果的入栈操作。函数结果的入栈顺序是第一个结果先入栈，因此调用完后最后一个结果会在栈顶。
调用Lua函数任何错误都会通过`longjmp`向上传递。
如下所示的是与Lua函数等价的C API调用。

```c
// lua code:
a = f("how", t.x, 14)
// do same work with c:
lua_getglobal(L, "f");                  /* function to be called */
lua_pushliteral(L, "how");                       /* 1st argument */
lua_getglobal(L, "t");                    /* table to be indexed */
lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
lua_remove(L, -2);                  /* remove 't' from the stack */
lua_pushinteger(L, 14);                          /* 3rd argument */
lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */
lua_setglobal(L, "a");                         /* set global 'a' */
```

> Note that the code above is *balanced*: at its end, the stack is back to its original configuration.
This is considered good programming practice.

注意的是上面的代码是*平衡的*：即在最后，栈的状态回到与原始状态一样。
这被认为是一种好的编程方法。

## lua_KFunction
```c
typedef int (*lua_KFunction)(lua_State* L, int status, lua_KContext ctx);
```
> Type for continuation functions (4.7).

> **lua_KContext**

> The type for continuation-function contexts. It must be a numeric type.
This type is deinfed as `intptr_t` when `intptr_t` is available, so that it can store pointers too.
Otherwise, it is defined as `ptrdiff_t`.

Continuation函数的类型（见4.7）。类型`lua_KContent`是Continuation函数的上下文。
它是一个数值类型，如果`intptr_t`存在则这个类型被定义成`intptr_t`，因此可以存储指针值。否则它被定义成`ptrdiff_t`。

## lua_callk [-(nargs+1),+nresults,e]
```c
void lua_callk(lua_State* L, int nargs, int nresults, lua_LContent ctx, lua_KFunction k);
```
> This function behaves exactly like `lua_call`, but allows the called function to yield (see 4.7).

该函数跟`lua_call`一样，但允许函数进行Yield。

### 代码追踪
```c
void lua_callk (lua_State* L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k) {
  StkId func = L->top - (nargs+1);
  if (k != NULL && L->nny == 0) {  /* need to prepare continuation? */
    L->ci->u.c.k = k;  /* save continuation */
    L->ci->u.c.ctx = ctx;  /* save context */
    luaD_call(L, func, nresults);  /* do the call */
  }
  else  /* no continuation or no yieldable */
    luaD_callnoyield(L, func, nresults);  /* just do the call */
  adjustresults(L, nresults);
}
void luaD_call(lua_State* L, StkId func, int nresults) {
  if (++L->nCcalls >= LUAI_MAXCCALLS) stackerror(L); // LUAI_MAXCCALLS: 200
  if (!luaD_precall(L, func, nresults)) luaV_execute(L);
  L->nCcalls--;
}
void luaD_callnoyield(lua_State* L, StdId func, int nresults) {
  L->nyy++;
  luaD_call(L, func, nresults);
  L->nyy--;
}

// C函数调用流程
// 1. 获取C闭包或C函数的函数指针
int luaD_precall(lua_State* L, StkId func, int nresults) {
  lua_CFunction f;
  CallInfo *ci;
  switch (ttype(func)) {
  case LUA_TCCL: // 如果是C closure，获取closure中存储的函数指针
    f = clCvalue(func)->f;
    goto Cfunc;
  case LUA_TLCF: // 如果是C函数，获取Lua值中存储的函数luaValue.value_.f
    f = fvalue(func);
    Cfunc:
    // ...
    return 1
  }
}
// 2.
Cfunc:
int n;  /* number of returns */
checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */
ci = next_ci(L);  /* now 'enter' new function */
ci->nresults = nresults;
ci->func = func;
ci->top = L->top + LUA_MINSTACK;
lua_assert(ci->top <= L->stack_last);
ci->callstatus = 0;
if (L->hookmask & LUA_MASKCALL)
  luaD_hook(L, LUA_HOOKCALL, -1);
lua_unlock(L);
n = (*f)(L);  /* do the actual call */
lua_lock(L);
api_checknelems(L, n);
luaD_poscall(L, ci, L->top - n, n);
return 1;
      
// Lua函数调用流程
```

## lua_pcall [-(nargs + 1), +(nresults|1), –]
```c
int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);
```

Calls a function in protected mode.
Both `nargs` and `nresults` have the same meaning as in `lua_call`. 
If there are no errors during the call, `lua_pcall` behaves exactly like `lua_call`. 
However, if there is any error, `lua_pcall` catches it, pushes a single value on the stack (the error message), 
and returns an error code. Like `lua_call`, `lua_pcall` always removes the function and its arguments from the stack.

用保护模式调用Lua函数。参数`nargs`和`nresults`的含义跟`lua_call`一样。
如果函数调用那个没有错误发生，`lua_pcall`与`lua_call`完全一样。
如果发生错误，`lua_pcall`会获取它，将错误消息入栈，并将错误代码返回。
像`lua_call`一样，`lua_pcall`将传入的参数以及栈底的函数从栈中移除。

If `msgh` is 0, then the error message returned on the stack is exactly the original error message. 
Otherwise, `msgh` is the stack index of a message handler. (This index cannot be a pseudo-index.) 
In case of runtime errors, this function will be called with the error message 
and its return value will be the message returned on the stack by `lua_pcall`.

参数`msgh`如果是0，入栈的错误消息与原始的错误消息一样。
否则，`msgh`代表栈中错误处理函数的索引值（这个索引可以是伪索引）。
当运行时错误发生时，这个错误处理函数会对应的错误消息调用，而`lua_pcall`压入到栈的值是这个处理函数返回的值。

Typically, the message handler is used to add more debug information to the error message, 
such as a stack traceback. Such information cannot be gathered after the return of `lua_pcall`, 
since by then the stack has unwound.

一般的，错误处理函数用于为错误消息添加额外的debug信息，如栈的追踪。
这些信息不能在`lua_pcall`执行完后去收集，因为此时Lua栈已经执行了展开操作回到以前的状态。

`lua_pcall`函数会返回的值如下（定义在lua.h中）。

The `lua_pcall` function returns one of the following constants (defined in lua.h):
- LUA_OK (0): success.
- LUA_ERRRUN: a runtime error.
- LUA_ERRMEM: memory allocation error. For such errors, Lua does not call the message handler.
- LUA_ERRERR: error while running the message handler.
- LUA_ERRGCMM: error while running a `__gc` metamethod. 
  (This error typically has no relation with the function being called.)

## lua_pcallk [-(nargs + 1), +(nresults|1), –]
```c
int lua_pcallk (lua_State *L, int nargs, int nresults, int msgh, lua_KContext ctx, lua_KFunction k);
```

This function behaves exactly like `lua_pcall`, but allows the called function to yield (see §4.7).

这个函数与`lua_pcall`的行为一样，除了允许被调用的函数yield。

---------------------------------------------------------------------------------------------------

pcall (f [, arg1, ···])

Calls function f with the given arguments in protected mode. This means that any error inside f is not propagated; instead, pcall catches the error and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, pcall also returns all results from the call, after this first result. In case of any error, pcall returns false plus the error message.


xpcall (f, msgh [, arg1, ···])

This function is similar to pcall, except that it sets a new message handler msgh. 
